using System.Collections.Generic;
using DMotion.Authoring;
using UnityEditor;
using UnityEngine;

namespace DMotion.Editor
{
    internal struct ParameterInspectorModel
    {
        internal StateMachineAsset StateMachine;
    }

    internal abstract class StateMachineInspector<T> : UnityEditor.Editor, IStateMachineInspector<T>
        where T : struct
    {
        protected T model;

        void IStateMachineInspector<T>.SetModel(T context)
        {
            model = context;
        }
    }

    /// <summary>
    /// Inspector for root parameters of a StateMachineAsset.
    /// Shows all parameters with status icons and allows add/delete operations.
    /// </summary>
    internal class ParametersInspector : StateMachineInspector<ParameterInspectorModel>
    {
        private List<AnimationParameterAsset> _orphanedParameters = new();
        private bool _needsRefresh = true;
        
        // Collapsible section
        private DockablePanelSection parametersSection;

        private void OnEnable()
        {
            EditorState.Instance.StructureChanged += OnStructureChanged;
            parametersSection = new DockablePanelSection("Parameters", "DMotion_Params", true);
        }

        private void OnDisable()
        {
            EditorState.Instance.StructureChanged -= OnStructureChanged;
        }

        private void OnStructureChanged(object sender, StructureChangedEventArgs e)
        {
            if (e.ChangeType == StructureChangeType.GeneralChange)
            {
                if (EditorState.Instance.RootStateMachine == model.StateMachine)
                {
                    _needsRefresh = true;
                    Repaint();
                }
            }
        }

        public override void OnInspectorGUI()
        {
            if (model.StateMachine == null || serializedObject?.targetObject == null)
            {
                return;
            }

            if (_needsRefresh)
            {
                RefreshAnalysis();
                _needsRefresh = false;
            }
            
            DrawParametersSection();
        }

        private void RefreshAnalysis()
        {
            // Early return if state machine is null or destroyed
            if (model.StateMachine == null || !model.StateMachine)
            {
                _orphanedParameters = new List<AnimationParameterAsset>();
                return;
            }
            
            try
            {
                _orphanedParameters = ParameterDependencyAnalyzer.FindOrphanedParameters(model.StateMachine);
            }
            catch (System.Exception e)
            {
                Debug.LogWarning($"[DMotion] Error analyzing orphaned parameters: {e.Message}");
                _orphanedParameters = new List<AnimationParameterAsset>();
            }
        }

        private void ForceRefresh()
        {
            _needsRefresh = true;
            RefreshAnalysis();
            Repaint();
        }

        private void DrawParametersSection()
        {
            serializedObject.Update();
            
            // Use collapsible section with Add button in toolbar
            if (!parametersSection.DrawHeader(() => DrawParametersToolbar(), showDockButton: false))
            {
                return;
            }

            var parametersProperty = serializedObject.FindProperty(nameof(StateMachineAsset.Parameters));
            if (parametersProperty == null) return;
            
            if (parametersProperty.arraySize == 0)
            {
                EditorGUILayout.HelpBox("No parameters defined. Add parameters to control transitions and blend trees.", MessageType.Info);
            }
            else
            {
                for (int i = 0; i < parametersProperty.arraySize; i++)
                {
                    DrawParameterRow(parametersProperty, i);
                }

                DrawOrphanCleanup();
            }
        }

        private void DrawParametersToolbar()
        {
            using (new EditorGUI.DisabledScope(Application.isPlaying))
            {
                var rect = EditorGUILayout.GetControlRect(GUILayout.Width(50));
                if (EditorGUI.DropdownButton(rect, GUIContentCache.AddButton, FocusType.Passive, EditorStyles.toolbarDropDown))
                {
                    ShowAddParameterMenu(rect);
                }
            }
        }

        private void DrawParameterRow(SerializedProperty parametersProperty, int index)
        {
            var paramProp = parametersProperty.GetArrayElementAtIndex(index);
            var param = paramProp.objectReferenceValue as AnimationParameterAsset;
            if (param == null) return;

            var isOrphaned = _orphanedParameters?.Contains(param) ?? false;
            var isAutoGenerated = param.IsAutoGenerated;
            var isLinked = IsParameterLinked(param);

            // Background color for special states
            var bgColor = isOrphaned ? new Color(1f, 0.9f, 0.5f, 0.3f) :
                          isAutoGenerated ? new Color(0.5f, 0.8f, 1f, 0.2f) :
                          Color.clear;

            var rect = EditorGUILayout.BeginHorizontal(EditorStyles.helpBox);
            if (bgColor != Color.clear)
            {
                EditorGUI.DrawRect(rect, bgColor);
            }

            // Status icon
            DrawParameterStatusIcon(param, isOrphaned, isAutoGenerated, isLinked);

            // Parameter field
            EditorGUILayout.PropertyField(paramProp, GUIContent.none);

            // Delete button
            using (new EditorGUI.DisabledScope(Application.isPlaying))
            {
                if (GUILayout.Button("X", GUILayout.Width(20)))
                {
                    DeleteParameter(index);
                }
            }

            EditorGUILayout.EndHorizontal();
        }

        // Cached tooltip strings to avoid allocations
        private const string TooltipOrphanedAutoGen = "Orphaned - auto-generated, safe to remove";
        private const string TooltipOrphanedManual = "Orphaned - not used by any state or transition";
        private const string TooltipLinked = "Linked to SubStateMachine parameter(s)";
        private const string TooltipAutoGenerated = "Auto-generated parameter";

        private void DrawParameterStatusIcon(AnimationParameterAsset param, bool isOrphaned, bool isAutoGenerated, bool isLinked)
        {
            GUIContent icon;
            
            if (isOrphaned)
            {
                icon = IconCache.WarnIconWithTooltip(isAutoGenerated ? TooltipOrphanedAutoGen : TooltipOrphanedManual);
            }
            else if (isLinked)
            {
                icon = IconCache.LinkedIconWithTooltip(TooltipLinked);
            }
            else if (isAutoGenerated)
            {
                icon = IconCache.TempIcon(IconCache.PrefabTexture, TooltipAutoGenerated);
            }
            else
            {
                icon = IconCache.TempIcon(GetParameterTypeIcon(param), param.ParameterTypeName);
            }

            GUILayout.Label(icon, GUILayout.Width(18), GUILayout.Height(18));
        }

        private Texture GetParameterTypeIcon(AnimationParameterAsset param)
        {
            if (param is EnumParameterAsset)
                return IconCache.FilterByTypeTexture;
            if (param is BoolParameterAsset)
                return IconCache.ToggleTexture;
            if (param is IntParameterAsset)
                return IconCache.GridTexture;
            if (param is FloatParameterAsset)
                return IconCache.BlendTreeTexture;
            
            return IconCache.ScriptableObjectTexture;
        }

        private void DrawOrphanCleanup()
        {
            if (_orphanedParameters == null || _orphanedParameters.Count == 0) return;

            int autoGenOrphans = 0;
            for (int i = 0; i < _orphanedParameters.Count; i++)
            {
                if (_orphanedParameters[i].IsAutoGenerated)
                    autoGenOrphans++;
            }
            
            EditorGUILayout.Space(2);
            using (new EditorGUILayout.HorizontalScope())
            {
                GUILayout.Label(IconCache.WarnIcon, GUILayout.Width(18));

                var msg = autoGenOrphans > 0
                    ? StringBuilderCache.FormatOrphanedWithAutoGen(_orphanedParameters.Count, autoGenOrphans)
                    : StringBuilderCache.FormatOrphaned(_orphanedParameters.Count);
                EditorGUILayout.LabelField(msg, EditorStyles.miniLabel);

                GUILayout.FlexibleSpace();

                if (autoGenOrphans > 0 && GUILayout.Button(GUIContentCache.CleanUpButton, EditorStyles.miniButton, GUILayout.Width(60)))
                {
                    CleanupOrphanedParameters();
                }
            }
        }

        #region Actions

        // Cached menu items - these only allocate once
        private static readonly GUIContent MenuBoolean = new GUIContent("Boolean");
        private static readonly GUIContent MenuInteger = new GUIContent("Integer");
        private static readonly GUIContent MenuFloat = new GUIContent("Float");
        private static readonly GUIContent MenuEnum = new GUIContent("Enum");

        private void ShowAddParameterMenu(Rect rect)
        {
            var menu = new GenericMenu();
            menu.AddItem(MenuBoolean, false, CreateParameter<BoolParameterAsset>);
            menu.AddItem(MenuInteger, false, CreateParameter<IntParameterAsset>);
            menu.AddItem(MenuFloat, false, CreateParameter<FloatParameterAsset>);
            menu.AddItem(MenuEnum, false, CreateParameter<EnumParameterAsset>);
            menu.DropDown(rect);
        }

        private void CreateParameter<T>() where T : AnimationParameterAsset
        {
            var param = model.StateMachine.CreateParameter<T>();
            EditorState.Instance.NotifyParameterAdded(param);
            serializedObject.ApplyAndUpdate();
        }

        private void DeleteParameter(int index)
        {
            if (index < 0 || index >= model.StateMachine.Parameters.Count)
                return;
                
            var param = model.StateMachine.Parameters[index];
            if (param == null) return;
            
            using (UndoScope.Begin("Delete Parameter", model.StateMachine))
            {
                RemoveLinksForParameter(param);
                model.StateMachine.DeleteParameter(param); // Now recursive by default
            }
            
            EditorState.Instance.NotifyParameterRemoved(param);
            
            // Force full refresh to update orphan analysis and UI
            ForceRefresh();
            serializedObject.Update();
        }
        
        private bool IsParameterLinked(AnimationParameterAsset param)
        {
            var links = model.StateMachine.ParameterLinks;
            for (int i = 0; i < links.Count; i++)
            {
                if (links[i].SourceParameter == param)
                    return true;
            }
            return false;
        }

        private void RemoveLinksForParameter(AnimationParameterAsset param)
        {
            model.StateMachine.RemoveLinksForParameter(param);
        }

        private void CleanupOrphanedParameters()
        {
            List<AnimationParameterAsset> removed;
            using (UndoScope.Begin("Cleanup Orphaned Parameters", model.StateMachine))
            {
                removed = ParameterDependencyAnalyzer.CleanupOrphanedParameters(model.StateMachine, onlyAutoGenerated: true);
            }
            
            if (removed.Count > 0)
            {
                ForceRefresh();
                serializedObject.Update();
            }
        }

        #endregion
    }
}
