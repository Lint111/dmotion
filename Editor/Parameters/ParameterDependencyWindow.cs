using System;
using System.Collections.Generic;
using DMotion.Authoring;
using UnityEditor;
using UnityEngine;

namespace DMotion.Editor
{
    /// <summary>
    /// Editor window for viewing and managing parameter dependencies in a StateMachineAsset.
    /// Shows which parameters are required by SubStateMachines and allows cleanup of orphaned parameters.
    /// </summary>
    internal class ParameterDependencyWindow : EditorWindow
    {
        private StateMachineAsset _targetMachine;
        private Vector2 _scrollPosition;
        private bool _showOrphansOnly;
        private bool _showAutoGeneratedOnly;
        
        // Cached analysis results
        private List<ParameterInfo> _parameterInfos = new();
        private List<AnimationParameterAsset> _orphanedParameters = new();
        private bool _needsRefresh = true;
        
        // Cached filtered list to avoid per-frame allocations
        private List<ParameterInfo> _filteredList = new();
        private bool _lastShowOrphansOnly;
        private bool _lastShowAutoGeneratedOnly;
        private bool _filterDirty = true;
        
        // Cached window title
        private static readonly GUIContent WindowTitleContent = new GUIContent("Parameter Dependencies");
        
        // Cached counts for summary (to avoid LINQ per frame)
        private int _cachedAutoGeneratedCount;
        private int _cachedSubMachineCount;
        
        // Cached labels for summary
        private static readonly GUIContent SummaryLabel = new GUIContent("Summary");
        private static readonly GUIContent ParametersLabel = new GUIContent("Parameters");
        private static readonly GUIContent ParameterLinksLabel = new GUIContent("Parameter Links");
        private static readonly GUIContent CleanupLabel = new GUIContent("Cleanup");

        [MenuItem("Window/DMotion/Parameter Dependencies")]
        public static void ShowWindow()
        {
            var window = GetWindow<ParameterDependencyWindow>();
            window.titleContent = WindowTitleContent;
            window.Show();
        }

        public static void ShowWindowForAsset(StateMachineAsset asset)
        {
            var window = GetWindow<ParameterDependencyWindow>();
            window.titleContent = WindowTitleContent;
            window._targetMachine = asset;
            window._needsRefresh = true;
            window.Show();
        }

        private void OnEnable()
        {
            _needsRefresh = true;
        }

        private void OnSelectionChange()
        {
            // Auto-select StateMachineAsset if selected in project
            if (Selection.activeObject is StateMachineAsset machine)
            {
                if (_targetMachine != machine)
                {
                    _targetMachine = machine;
                    _needsRefresh = true;
                    Repaint();
                }
            }
        }

        private void OnGUI()
        {
            DrawToolbar();
            
            if (_targetMachine == null)
            {
                EditorGUILayout.HelpBox(
                    "Select a StateMachineAsset in the Project window or drag one here.",
                    MessageType.Info);
                
                // Allow drag-drop
                var dropArea = GUILayoutUtility.GetRect(0, 50, GUILayout.ExpandWidth(true));
                var evt = Event.current;
                if (dropArea.Contains(evt.mousePosition))
                {
                    if (evt.type == EventType.DragUpdated)
                    {
                        if (HasStateMachineInDragDrop())
                        {
                            DragAndDrop.visualMode = DragAndDropVisualMode.Link;
                            evt.Use();
                        }
                    }
                    else if (evt.type == EventType.DragPerform)
                    {
                        var machine = FindStateMachineInDragDrop();
                        if (machine != null)
                        {
                            _targetMachine = machine;
                            _needsRefresh = true;
                            evt.Use();
                        }
                    }
                }
                
                GUI.Box(dropArea, "Drop StateMachineAsset here", EditorStyles.helpBox);
                return;
            }

            if (_needsRefresh)
            {
                RefreshAnalysis();
                _needsRefresh = false;
            }

            DrawContent();
        }

        private void DrawToolbar()
        {
            using (new EditorGUILayout.HorizontalScope(EditorStyles.toolbar))
            {
                // Target asset field
                EditorGUI.BeginChangeCheck();
                _targetMachine = (StateMachineAsset)EditorGUILayout.ObjectField(
                    _targetMachine, 
                    typeof(StateMachineAsset), 
                    false,
                    GUILayout.Width(200));
                if (EditorGUI.EndChangeCheck())
                {
                    _needsRefresh = true;
                }

                GUILayout.FlexibleSpace();

                // Filters
                EditorGUI.BeginChangeCheck();
                _showOrphansOnly = GUILayout.Toggle(_showOrphansOnly, "Orphans Only", EditorStyles.toolbarButton);
                _showAutoGeneratedOnly = GUILayout.Toggle(_showAutoGeneratedOnly, "Auto-Gen Only", EditorStyles.toolbarButton);
                if (EditorGUI.EndChangeCheck())
                {
                    Repaint();
                }

                // Refresh button
                if (GUILayout.Button("Refresh", EditorStyles.toolbarButton, GUILayout.Width(60)))
                {
                    _needsRefresh = true;
                }
            }
        }

        private void DrawContent()
        {
            _scrollPosition = EditorGUILayout.BeginScrollView(_scrollPosition);

            // Summary section
            DrawSummary();
            
            EditorGUILayout.Space(10);

            // Parameters list
            DrawParametersList();
            
            EditorGUILayout.Space(10);

            // Links section
            DrawLinksSection();
            
            EditorGUILayout.Space(10);

            // Cleanup section
            DrawCleanupSection();

            EditorGUILayout.EndScrollView();
        }

        private void DrawSummary()
        {
            EditorGUILayout.LabelField(SummaryLabel, EditorStyles.boldLabel);
            
            using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))
            {
                var sb = StringBuilderCache.Get();
                
                sb.Append("Total Parameters: ").Append(_targetMachine.Parameters.Count);
                EditorGUILayout.LabelField(sb.ToString());
                
                sb.Clear().Append("Auto-Generated: ").Append(_cachedAutoGeneratedCount);
                EditorGUILayout.LabelField(sb.ToString());
                
                sb.Clear().Append("Orphaned: ").Append(_orphanedParameters.Count);
                EditorGUILayout.LabelField(sb.ToString());
                
                sb.Clear().Append("Parameter Links: ").Append(_targetMachine.ParameterLinks.Count);
                EditorGUILayout.LabelField(sb.ToString());
                
                sb.Clear().Append("SubStateMachines: ").Append(_cachedSubMachineCount);
                EditorGUILayout.LabelField(sb.ToString());
            }
        }

        private void DrawParametersList()
        {
            EditorGUILayout.LabelField(ParametersLabel, EditorStyles.boldLabel);
            
            // Rebuild filtered list only when filter changes
            if (_filterDirty || _lastShowOrphansOnly != _showOrphansOnly || _lastShowAutoGeneratedOnly != _showAutoGeneratedOnly)
            {
                _filteredList.Clear();
                for (int i = 0; i < _parameterInfos.Count; i++)
                {
                    var p = _parameterInfos[i];
                    if (_showOrphansOnly && !p.IsOrphan) continue;
                    if (_showAutoGeneratedOnly && !p.IsAutoGenerated) continue;
                    _filteredList.Add(p);
                }
                _lastShowOrphansOnly = _showOrphansOnly;
                _lastShowAutoGeneratedOnly = _showAutoGeneratedOnly;
                _filterDirty = false;
            }
            
            if (_filteredList.Count == 0)
            {
                EditorGUILayout.HelpBox("No parameters match the current filter.", MessageType.Info);
                return;
            }

            for (int i = 0; i < _filteredList.Count; i++)
            {
                DrawParameterRow(_filteredList[i]);
            }
        }

        private void DrawParameterRow(ParameterInfo info)
        {
            using (new EditorGUILayout.HorizontalScope(EditorStyles.helpBox))
            {
                // Icon/status - use cached icons
                var icon = info.IsOrphan ? IconCache.WarnIcon : 
                           info.IsAutoGenerated ? IconCache.PrefabIcon :
                           IconCache.ScriptableObjectIcon;
                GUILayout.Label(icon, GUILayout.Width(20), GUILayout.Height(18));

                // Name and type
                using (new EditorGUILayout.VerticalScope())
                {
                    EditorGUILayout.LabelField(info.Parameter.name, EditorStyles.boldLabel);
                    
                    // Build type label without allocations
                    var sb = StringBuilderCache.Get();
                    sb.Append(info.Parameter.ParameterTypeName);
                    if (info.IsAutoGenerated) sb.Append(" [Auto]");
                    if (info.IsOrphan) sb.Append(" [Orphan]");
                    
                    EditorGUILayout.LabelField(sb.ToString(), EditorStyles.miniLabel);
                }

                GUILayout.FlexibleSpace();

                // Required by count
                if (info.RequiredByCount > 0)
                {
                    EditorGUILayout.LabelField(StringBuilderCache.FormatUsedByCount(info.RequiredByCount), 
                        EditorStyles.miniLabel, GUILayout.Width(150));
                }

                // Select button
                if (GUILayout.Button("Select", GUILayout.Width(50)))
                {
                    Selection.activeObject = info.Parameter;
                    EditorGUIUtility.PingObject(info.Parameter);
                }
            }
        }

        private void DrawLinksSection()
        {
            EditorGUILayout.LabelField(ParameterLinksLabel, EditorStyles.boldLabel);

            var links = _targetMachine.ParameterLinks;
            if (links.Count == 0)
            {
                EditorGUILayout.HelpBox("No parameter links defined.", MessageType.Info);
                return;
            }

            for (int i = 0; i < links.Count; i++)
            {
                var link = links[i];
                if (!link.IsValid) continue;

                using (new EditorGUILayout.HorizontalScope(EditorStyles.helpBox))
                {
                    EditorGUILayout.LabelField(link.SourceParameter.name, GUILayout.Width(120));
                    EditorGUILayout.LabelField("->", GUILayout.Width(25));
                    EditorGUILayout.LabelField(link.TargetParameter.name, GUILayout.Width(120));
                    var containerName = link.NestedContainer?.name ?? "(unknown)";
                    EditorGUILayout.LabelField(StringBuilderCache.FormatInName(containerName), EditorStyles.miniLabel);
                    
                    if (link.Transform.HasTransform)
                    {
                        EditorGUILayout.LabelField(
                            StringBuilderCache.FormatTransform(link.Transform.Scale, link.Transform.Offset), 
                            EditorStyles.miniLabel, GUILayout.Width(80));
                    }
                }
            }
        }

        private void DrawCleanupSection()
        {
            EditorGUILayout.LabelField(CleanupLabel, EditorStyles.boldLabel);

            using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))
            {
                if (_orphanedParameters.Count > 0)
                {
                    var sb = StringBuilderCache.Get();
                    sb.Append("Found ").Append(_orphanedParameters.Count).Append(" orphaned parameter(s) that are no longer used.");
                    EditorGUILayout.HelpBox(sb.ToString(), MessageType.Warning);

                    using (new EditorGUILayout.HorizontalScope())
                    {
                        if (GUILayout.Button("Remove Auto-Generated Orphans"))
                        {
                            RemoveOrphanedParameters(onlyAutoGenerated: true);
                        }
                        
                        if (GUILayout.Button("Remove All Orphans"))
                        {
                            if (EditorUtility.DisplayDialog(
                                "Remove All Orphaned Parameters",
                                "This will remove all parameters that are not used by any state or transition. " +
                                "This includes manually created parameters. Are you sure?",
                                "Remove", "Cancel"))
                            {
                                RemoveOrphanedParameters(onlyAutoGenerated: false);
                            }
                        }
                    }
                }
                else
                {
                    EditorGUILayout.HelpBox("No orphaned parameters found.", MessageType.Info);
                }

                EditorGUILayout.Space(5);

                if (GUILayout.Button("Re-analyze All SubStateMachines"))
                {
                    ReanalyzeAllSubMachines();
                }
            }
        }

        private void RefreshAnalysis()
        {
            _parameterInfos.Clear();
            _orphanedParameters.Clear();
            _filterDirty = true;
            _cachedAutoGeneratedCount = 0;
            _cachedSubMachineCount = 0;

            if (_targetMachine == null) return;

            // Analyze orphaned parameters
            _orphanedParameters = ParameterDependencyAnalyzer.FindOrphanedParameters(_targetMachine);

            // Build parameter info list and count auto-generated
            var parameters = _targetMachine.Parameters;
            for (int i = 0; i < parameters.Count; i++)
            {
                var param = parameters[i];
                var isAutoGen = param.IsAutoGenerated;
                if (isAutoGen) _cachedAutoGeneratedCount++;
                
                var info = new ParameterInfo
                {
                    Parameter = param,
                    IsAutoGenerated = isAutoGen,
                    IsOrphan = _orphanedParameters.Contains(param),
                    RequiredByCount = param.RequiredBySubMachines.Count
                };
                _parameterInfos.Add(info);
            }

            // Count SubStateMachines
            foreach (var _ in _targetMachine.GetAllGroups())
            {
                _cachedSubMachineCount++;
            }

            // Sort: orphans first, then auto-generated, then by name
            _parameterInfos.Sort(CompareParameterInfo);
        }
        
        private static int CompareParameterInfo(ParameterInfo a, ParameterInfo b)
        {
            // Orphans first (descending - true before false)
            if (a.IsOrphan != b.IsOrphan)
                return a.IsOrphan ? -1 : 1;
            
            // Then auto-generated (descending)
            if (a.IsAutoGenerated != b.IsAutoGenerated)
                return a.IsAutoGenerated ? -1 : 1;
            
            // Then by name (ascending)
            return string.Compare(a.Parameter.name, b.Parameter.name, StringComparison.Ordinal);
        }

        private void RemoveOrphanedParameters(bool onlyAutoGenerated)
        {
            Undo.RecordObject(_targetMachine, "Remove Orphaned Parameters");

            var removed = ParameterDependencyAnalyzer.CleanupOrphanedParameters(_targetMachine, onlyAutoGenerated);
            
            if (removed.Count > 0)
            {
                var sb = StringBuilderCache.Get();
                sb.Append("[DMotion] Removed ").Append(removed.Count).Append(" orphaned parameter(s)");
                Debug.Log(sb.ToString());
            }

            _needsRefresh = true;
        }

        private void ReanalyzeAllSubMachines()
        {
            if (_targetMachine == null) return;

            Undo.RecordObject(_targetMachine, "Re-analyze Parameter Dependencies");

            // Clear existing dependency data
            _targetMachine.ClearAllDependencyData();

            // Re-analyze each SubStateMachine
            foreach (var subMachine in _targetMachine.GetAllGroups())
            {
                var result = ParameterDependencyAnalyzer.ResolveParameterDependencies(_targetMachine, subMachine);
                
                // Register links
                if (result.HasLinks)
                {
                    _targetMachine.AddParameterLinks(result.ParameterLinks);
                }

                // Create missing parameters
                if (result.HasMissingParameters)
                {
                    var assetPath = AssetDatabase.GetAssetPath(_targetMachine);
                    ParameterDependencyAnalyzer.CreateMissingParameters(
                        _targetMachine, subMachine, result.MissingParameters, assetPath);
                }
            }

            EditorUtility.SetDirty(_targetMachine);
            _needsRefresh = true;

            var logSb = StringBuilderCache.Get();
            logSb.Append("[DMotion] Re-analyzed parameter dependencies for ").Append(_targetMachine.name);
            Debug.Log(logSb.ToString());
        }

        private struct ParameterInfo
        {
            public AnimationParameterAsset Parameter;
            public bool IsAutoGenerated;
            public bool IsOrphan;
            public int RequiredByCount;
        }
        
        // Helper methods to replace LINQ in drag-drop
        private static bool HasStateMachineInDragDrop()
        {
            var refs = DragAndDrop.objectReferences;
            for (int i = 0; i < refs.Length; i++)
            {
                if (refs[i] is StateMachineAsset)
                    return true;
            }
            return false;
        }
        
        private static StateMachineAsset FindStateMachineInDragDrop()
        {
            var refs = DragAndDrop.objectReferences;
            for (int i = 0; i < refs.Length; i++)
            {
                if (refs[i] is StateMachineAsset machine)
                    return machine;
            }
            return null;
        }
    }
}
